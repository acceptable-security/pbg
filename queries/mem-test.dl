.type address = number
.type step = symbol

.decl next_step(from: step, to: step)
.decl step_address(from: step, to: address)

.decl malloc_amt(at_step: step, size: number)
.decl malloc_ptr(at_step: step, ptr: number)

.decl next_address(from: address, to: address)
.decl write_address(pc: address, dest: address)
.decl read_address(pc: address, from: address)

.decl free(pc: address, addr: address)
.decl text_at_pc(line: symbol, pc: address)

.input write_address
.input read_address
.input malloc
.input free
.input text_at_pc

.decl malloc(at_step: step, size: number, heap_addr: address)
malloc(a, s, h) :- malloc_amt(a, s), malloc_ptr(a, h).

.decl next_step_no_free(from_step: step, next_step: step, heap_addr: address)
next_step_no_free(x, y, h) :- next_step(x, y), malloc_ptr(_, h), !free(y, h).

.decl reach_without_free(from_step: step, dest_step: step, heap_addr: address)
reach_without_free(x, y, h) :-
    next_step_no_free(x, y, h) ;
    next_step_no_free(x, z, h), next_step_no_free(z, y, h).

.decl malloc_reach(alloc_step: step, dest_step: step, heap_addr: address, heap_size: number)
malloc_reach(a, d, h, s) :-
    malloc(a, s, h), reach_without_free(a, d, h).

.decl invalid_heap_access(pc: address, dest: address, type: symbol)
invalid_heap_access(p, d, t) :-
    (write_address(p, d), t="write"; read_address(p, d), t="read"),
    step_address(p, x),
    malloc_reach(_, x, d2, s),
    (d < d2 ; d >= d2 + s). // Bounds check

.decl invalid_free(pc: address, dest: address)
invalid_free(p, d) :- free(p, d), !malloc_reach(_, p, _, _).

.output invalid_free
.output invalid_heap_access